// SPDX-License-Identifier: UNLICENSED

pragma solidity >=0.7.0 <0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol";
import "./AccessRestriction.sol";

/**
 * @notice Abstract class representing token approvals.
 */
abstract contract Approvable is Initializable, ContextUpgradeable {

    using SafeMathUpgradeable for uint256;
    using AddressUpgradeable for address;

    function __Approvable_init() internal initializer {
        __Context_init_unchained();
        __Approvable_init_unchained();
    }

    function __Approvable_init_unchained() internal initializer {
    }

    // Mapping from token ID to approved address
    mapping (uint256 => address) private tokenApprovals;

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);


    /**
     * @dev See {IERC721-approve}.
     */
    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ERC721Upgradeable.ownerOf(tokenId);
        require(to != owner, "ERC721: approval to current owner");

        require(_msgSender() == owner || ERC721Upgradeable.isApprovedForAll(owner, _msgSender()),
            "ERC721: approve caller is not owner nor approved for all"
        );

        _approve(to, tokenId);
    }

    /**
     * @dev See {IERC721-getApproved}.
     */
    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        return tokenApprovals[tokenId];
    }

    function _approve(address to, uint256 tokenId) private {
        tokenApprovals[tokenId] = to;
        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId); // internal owner
    }
}
